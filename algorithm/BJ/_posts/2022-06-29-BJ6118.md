---
layout: post
title: BJ_3184
categories: [algorithm]
tags: [algorithm]
description: >
  BJ_Algorithm_Java
invert_sidebar: false
---
# [BJ] 6118  ìˆ¨ë°”ê¼­ì§ˆ

 ***ğŸ¹Â ë¬¸ì œ ë§í¬***

[6118ë²ˆ: ìˆ¨ë°”ê¼­ì§ˆ](https://www.acmicpc.net/problem/6118)

âœï¸Â ***í’€ê¸° ì „ ë©”ëª¨*** 

> **ì–‘ë°©í–¥ ê·¸ë˜í”„**
í–‰ë ¬ë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒ ë³´ë‹¤ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ í˜•ì‹ì´ íš¨ìœ¨ì 
> 
> 
> Data>
> 
> ì¸ì ‘ë¦¬ìŠ¤íŠ¸
> 
> Solution>
> 
> BFS
> 
> queueì— ì •ì ì„ ì¶”ê°€í•˜ë©´ì„œ, ìµœëŒ“ê°’ í•¨ê»˜ ê°±ì‹ 
> 

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

/* BJ_6118_ìˆ¨ë°”ê¼­ì§ˆ */
public class BJ_6118_ìˆ¨ë°”ê¼­ì§ˆ {
	
	static class Point{
		int pos; 
		int move; 
		
		Point(int pos, int move){
			this.pos = pos; 
			this.move = move; 
		}
	}

	static int N; // í—›ê°„ ê°œìˆ˜ / 2ì´ìƒ 20,000 ì´í•˜
	static int M; // ê¸¸ì˜ ê°¯ìˆ˜ / ìµœëŒ€ 50,000 / ì–‘ë°©í–¥ 

	static ArrayList<ArrayList<Integer>> list = new ArrayList<>(); 
	static int[] ansList; 
	static boolean[] V; 
	static int maxAns = -1; 

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(br.readLine()," "); 
		N = Integer.parseInt(st.nextToken()); 
		M = Integer.parseInt(st.nextToken()); 

		ansList = new int[N+1]; 
		V = new boolean[N+1];

		// ì¸ì ‘ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™” 
		for (int i = 0; i <= N; i++) {
			list.add(new ArrayList<>());
		}

		// Mê°œ / ì–‘ë°©í–¥ ì—°ê²°
		for (int i = 0; i < M; i++) {
			st = new StringTokenizer(br.readLine(), " ");
			int from = Integer.parseInt(st.nextToken()); 
			int to = Integer.parseInt(st.nextToken()); 

			list.get(from).add(to); 
			list.get(to).add(from); 
		}
	
		bfs(1); 

		// ìµœëŒ“ê°’ì„ ê°€ì§€ëŠ” index ì¤‘ ìµœì†Ÿê°’ , ê°™ì€ ìµœëŒ“ê°’ ê°¯ìˆ˜ ì°¾ê¸° 
		int minIdx = N+1; 
		int minCnt = 0; 
		
		for (int j = 0; j < ansList.length; j++) {
			if(ansList[j] == maxAns) {
				minIdx = Math.min(minIdx, j);  
				minCnt++; 
			}
		}

		System.out.println(minIdx + " " + maxAns + " " + minCnt);

	}

	private static void bfs(int goal) {
		Queue<Point> q = new LinkedList<>();
		q.add(new Point(1, 0)); // í•­ìƒ 1ë¶€í„° ì‹œì‘
		V[1] = true; 

		while(!q.isEmpty()) {
			Point curr = q.poll(); 

			for (int a : list.get(curr.pos)) {
				if(!V[a]) {
					q.add(new Point(a, curr.move+1));
					ansList[a] = curr.move+1; 
					V[a] = true; 
					// ìµœëŒ“ê°’ ì°¾ê¸° 
					maxAns = Math.max(maxAns, ansList[a]);
				}
			}
		} // end : while
	}
}
```